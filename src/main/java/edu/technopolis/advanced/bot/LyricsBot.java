package edu.technopolis.advanced.bot;

import java.io.IOException;
import java.util.Objects;
import java.util.Properties;

import edu.technopolis.advanced.bot.request.*;
import edu.technopolis.advanced.bot.response.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.technopolis.advanced.bot.incoming.request.Message;
import edu.technopolis.advanced.bot.incoming.request.MessageNotification;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class LyricsBot {
    private static final Logger log = LoggerFactory.getLogger(LyricsBot.class);

    public static void main(String[] args) {
        Properties props = new Properties();
        log.info("Reading application properties...");
        try {
            props.load(LyricsBot.class.getResourceAsStream("/application.properties"));
        } catch (IOException e) {
            log.error("Failed to read application properties. Terminating application...");
            System.exit(1);
        }
        ApiClient okClient = createClient(props);
        try {
            GetSubscriptionsResponse response = okClient.get(
                    new GetSubscriptionsRequest(props.getProperty("ok.api.endpoint.subscriptions")), GetSubscriptionsResponse.class);
            String botEndpoint = props.getProperty("bot.message.endpoint");
//            unsubscribeAll(okClient, props, response);
            log.info("Checking that bot is subscribed to messages...");
            if (checkSubscribed(botEndpoint, response)) {
                log.info("Subscription exists");
            } else {
                log.info("Subscription does not exist. Making a subscription...");
                subscribe(okClient, props, botEndpoint);
                log.info("Subscription is ok");
            }
            log.info("Creating endpoint...");
            LyricsApiClient lyricsApiClient = createLyricsClient(props);
            BotServer server = createServer(okClient, props, lyricsApiClient);
            log.info("Server created. Waiting for incoming connections...");
            addShutDownHooks(server, okClient);
        } catch (Exception e) {
            log.error("Unexpected failure", e);
            closeClient(okClient);
            System.exit(1);
        }
    }

    private static void addShutDownHooks(BotServer server, ApiClient okClient) {
        Runtime
                .getRuntime()
                .addShutdownHook(new Thread(() -> {
                    closeClient(okClient);
                    server.stop();
                    log.error("Stopping server");
                }));
    }

    private static void closeClient(ApiClient client) {
        if (client != null) {
            try {
                client.close();
            } catch (IOException ce) {
                log.error("Failed to close client", ce);
            }
        }
    }

    private static void subscribe(ApiClient client, Properties props, String botEndpoint) throws IOException {
        SubscribeRequest req = new SubscribeRequest(props.getProperty("ok.api.endpoint.subscribe"),
                new SubscribePayload(botEndpoint));
        SubscribeResponse post = client.post(req, SubscribeResponse.class);
        if (!post.isSuccess()) {
            throw new IllegalStateException("Failed to subscribe bot to messages");
        }
    }

    private static void unsubscribe(ApiClient client, Properties properties, String botEndpoint) throws IOException {
        UnsubscribeRequest req = new UnsubscribeRequest(properties.getProperty("ok.api.endpoint.unsubscribe"),
                new UnsubscribePayload(botEndpoint));
        SubscribeResponse post = client.post(req, SubscribeResponse.class);
        if (!post.isSuccess()) {
            throw new IllegalStateException("Failed to unsubscribe bot to messages");
        }
    }

    private static void unsubscribeAll(ApiClient client, Properties properties , GetSubscriptionsResponse subscriptionsResponse) throws IOException {
        for (Subscription subscription : subscriptionsResponse.getSubscriptions()) {
            unsubscribe(client, properties, subscription.getUrl());
        }
    }

    private static boolean checkSubscribed(String botEndpoint, GetSubscriptionsResponse subscriptionsResponse) {
        if (subscriptionsResponse.getSubscriptions() == null || subscriptionsResponse.getSubscriptions().isEmpty()) {
            return false;
        }

        for (Subscription subscription : subscriptionsResponse.getSubscriptions()) {
            if (Objects.equals(subscription.getUrl(), botEndpoint)) {
                return true;
            }
        }
        return false;
    }

    private static ApiClient createClient(Properties props) {
        String schema = props.getProperty("ok.api.schema", "https");
        String host = props.getProperty("ok.api.host");
        String tokenParamName = props.getProperty("ok.api.param.token");
        String token = props.getProperty("ok.api.access_token");
        return new ApiClient(schema, host, tokenParamName + '=' + token);
    }

    private static LyricsApiClient createLyricsClient(Properties prop) {
        return new LyricsApiClient(prop.getProperty("lyrics.api.schema"),
                prop.getProperty("lyrics.api.host"),
                null);
    }

    private static BotServer createServer(ApiClient okClient, Properties props, LyricsApiClient lyricsApiClient) throws IOException {
        try {
            return new BotServer(
                    props.getProperty("bot.message.local.endpoint"),
                    new MessageSender(okClient, props, lyricsApiClient)::send
            ).start();
        } catch (IOException e) {
            log.error("Failed to initialize http server on port 80");
            throw e;
        }
    }

    private static class MessageSender {

        private final ApiClient client;
        private final LyricsApiClient lyricsClient;
        private final String phrase;
        private final String sendEndpoint;
        private final String lyricsQueryTemplate;
        private final String ERROR_MESSAGE;


        MessageSender(ApiClient okClient, Properties props, LyricsApiClient lyricsClient) {
            this.client = okClient;
            this.phrase = props.getProperty("bot.phrase");
            this.sendEndpoint = props.getProperty("ok.api.endpoint.send");
            this.lyricsQueryTemplate = props.getProperty("lyrics.api.endpoint.song.template");
            this.lyricsClient = lyricsClient;
            this.ERROR_MESSAGE = props.getProperty("bot.message.error_msg");
        }

        boolean send(MessageNotification notif) {
            if (notif == null || notif.getMessage() == null || notif.getMessage().getText() == null) {
                log.info("Message notification contains no text <{}>", notif);
                return true;
            }
            if (notif.getRecipient() == null || notif.getRecipient().getChatId() == null) {
                log.warn("Message notification does not contain chat id <{}>", notif);
                return false;
            }
            String answerMessage = getLyrics(notif);

            SendMessageRequest req = new SendMessageRequest(sendEndpoint, notif.getRecipient().getChatId())
                    .setPayload(
                            new SendMessagePayload(
                                    new SendRecipient(notif.getSender().getUserId()),
                                    new Message(answerMessage)
                            )
                    );
            try {
                return client.post(req, SendMessageResponse.class).getMessageId() != null;
            } catch (IOException e) {
                log.error("Failed to send message", e);
                return false;
            }
        }


        private String getLyrics(MessageNotification notification) {
            String songName = notification.getMessage().getText();
            String[] songProps = songName.split("-");
            if (songProps.length != 2) {
                return ERROR_MESSAGE;
            }
            for (int i = 0; i < songProps.length; i++) {
                songProps[i] = songProps[i].replace(" ", "+");
            }
            String lyricsQuery = String.format(lyricsQueryTemplate, songProps[0], songProps[1]);
            try {
                LyricsResponse lyricsResponse = lyricsClient.get(new LyricsRequest(lyricsQuery));
                return lyricsResponse.toString();
            } catch (IOException e) {
                log.error("Failed to sent lyrics request", e);
                return "Huston, we've got problems";
            }
        }
    }

}
